## 처음부터 “Recognize what is and what isn’t first-class” 직전까지 읽고 코딩

21:05 ~ 21:25

## 함께 코드 보며 토론

21:25 ~ 21:45

// June
### 냄새: 함수 이름에 있는 암묵적 인자
- setPriceByName, setQuntityByName, set…ByName —> 다 비슷하고 필드만 다르다. 함수명에 포함된 문자열만 다르다.

### 리팩터링: 암묵적 인자를 드러내기
- setPriceByName —> setFieldName(field: string)

### 일급인 것과 일급이 아닌 것을 구별하기
- 일급: 숫자, 문자열, 불리언 값 처럼 함수에 인자로 넘길 수 있고 함수의 리턴값으로 받을 수 있는 것
- 일급이 아닌것: +, *같은 연산자, 반복문, 조건문 등
- 함수명은 일급이 아니기 때문에 함수명의 일급을 인자로 바꿔 일급으로 만든다

// ak
- 코드 냄새에 민감해지기. 특히 중복에 민감해지면 좋음
- "Express implicit argument" 리팩토링은 보통 다른 책들에서는 "parameterize"라고 부름
- "Replace body with callback"은 지난 토론 때 말했던 higher-order function을 이용하여 상위 수준의 모듈을 재사용하는 방법의 하나.
- "Implicit argument in function name" 냄새를 따로 기억하지 않더라도 중복을 제거하려는 노력을 하다보면 자연스럽게 문제를 발견할 수 있음.
- 정적 타입이 없는 상황에서 setFieldByName() 형태로 리팩토링을 하는 건 약간 위험해 보임. 단위 테스트를 촘촘하게 작성하지 않으면 언젠가 문제가 생길 코드.
- 언제 OOP를 쓰고 언제 FP를 쓸까?
  - 둘 중 하나를 고른다기보다는 둘 다 알아뒀다가 잘 섞어쓰면 좋다고 생각해요. 실무에서 많이 쓰는 언어들은 대체로 두 패러다임을 다 지원하는 편
  - 순수 함수형 언어도 데이터와 함수를 캡슐화하는 방법을 제공하기도 함. 그래서 이 책의 예시처럼 함수와 데이터가 주욱 열거된 느낌이 덜 들게 할 수 있음
  - 대부분의 언어에는 이름공간namespace 개념이 있으므로 이걸 활용해서 모듈들을 관리하는 방법도 일반적

## “First-class functions can replace any syntax” 직전까지 읽기

21:45 ~ 22:05

## 토론

22:05 ~ 22:20

// ak
- expression이 아닌 statement가 되도록 없으면 좋겠어요 :)
  ```
  // 이런 거 하고 싶어요...  
  const x = if (a > b) {
    // do something
  } else {
    // do something else
  }
  ```
- 언어의 어떤 construct가 first-class라면? 해당 construct가 차별없이 쓰일 수 있다는 뜻
  (함수가 first-class construct라는 건 함수가 차별없이 쓰일 수 있다는 뜻)
- "Will field names as strings lead to more bugs?"
- API 변화를 TS로 어떻게 하면 잘 표현할 수 있을지 시도해보다가 시간 부족으로 못함
- "An important advantage of data is that data can be interpreted in multiple ways." 이 장점은 양날의 검. (거의) 모든 프로그래밍 언어는 데이터가 사용되는 방식을 제한하여 복잡성을 관리하기 때문. FP도 마찬가지.
- "프로세스 경계를 넘을 때에는 모든 게 문자열이다(정확히는 binary stream)"라는 주장은 약간 억지스러움.
- 잠을 푹 자자. 

// June
### 객체와 배열을 너무 많이 쓰게 됩니다
- 데이터 지향(Data Orientation)
    - 이벤트와 엔티티에 대한 사실을 표현하기 위해 일반generic 데이터 구조를 사용하는 프로그래밍 형식 = ?? 일반 데이터 구조란 무엇일까. 일반 = generic (!!!)
    - 이 섹션의 소제목: "We will use a lot of objects and arrays" // 객체와 배열을 너무 많이 쓰게 됩니다 (한글)
    - "Data orientation is a style of programming that uses generic data structures (e.g. Array, Object) to represent facts about events and entities."
    - 데이터를 사용할 때 임의의 인터페이스로 감싸지 않고 그대로 사용한다 = 새로운 데이터 구조(클래스 등)을 만들지 않고 있는 구조 (array, object)를 사용한다
- 정적 타입 vs 동적 타입
    - 정적 타입: 컴파일할 때 타입을 검사 — 타입스크립트 (선호 & 요즘의 대세인 것 같죠)
    - 동적 타입: 런타임에 타입을 확인 — 자바스크립트 (유연하지만 타입문제로 생기는 버그를 너무 늦게 알게된다)
- 모두 문자열로 통신합니다 : It’s all strings on the wire
    - API 데이터는 런타임에 체크하지만, codeGenerator에서 타입체크를 해줄 수도 있지 않을까? +1
    - 데이터의 단점: 항상 해석이 필요하다는 것?
      
      An important "advantage" of data is that data can be interpreted in multiple ways. =>
      We’re seeing one "downside" of data: It requires interpretation.

## 끝까지 읽기

22:33 ~ 22:50

## 토론

22:50 ~ 23:00

// ak
- 함수와 객체의 문법적 차이
  - `receiver.message(param)`
  - `message(receiver, param)`
  - `foods.forEach(f => {cook(f); eat(f)})`
  - `forEach(foods, f => {cook(f); eat(f)})`
- `const loggingF = withLogging(f)`는 decorator
  `@logging f() {...}`
- `cookAndEat(food)`는 `cookAndEat(food, cook, eat)`으로 바꾸면 OO의 Template method 패턴

// June
- 일급값: 변수에 저장할 수 있고 인자로 전달하거나 함수의 리턴값으로 사용
- 일급함수: 일급값인 함수
- 고차함수: 함수를 인자로 받거나(콜백) 함수를 리턴하는 함수
- 중복되는 동작을 함수 이름에서 냄새를 맡을 수 있어야 한다. 중복되는 동작은 고차함수 내에서 중복되는 부분을 처리하고, 다른 동작은 콜백으로 받아 처리할 수 있다

// Jin
- 콜백으로 빼내서 추상화하는 걸 즐겨했었(?)는데 요즘 과거의 제가 쓴 추상화에 '이게 뭐야?'할 때가 많아서 요즘 좀 난처할 떄가 있어요
```
const withLogging = (action: Function): void => {
  return function(option: any) {
    try {
      action(option);
    } catch (error) {
      logToSnapErros(error);
    }
  }
};

function doSomething(x) {...}

const doSomethingWithLogging = withLogging(doSomething);
doSomethingWithLogging(x);
```

## 회고

23:00 ~ 23:05
